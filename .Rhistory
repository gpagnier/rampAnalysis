{return(mean(c(a5head,a5tail)))}
else if (d[row,3]==5.6)
{return(5.6)}
else if (d[row,3]>5.6&d[row,3]<5.977)
{return(mean(c(a7head,a8tail)))}
else if (d[row,3]>=a9head&d[row,3]<=a9tail)
{return(mean(c(a9head,a9tail)))}
else
{return(999)}
}
#The number of statements in this function should match
#This block works well for participants 228 on..
binTimeCalc<-function(d,row){
if(d[row,3]==0)
{return(0)}
else if (d[row,3]>0&d[row,3]<=a1tail)
{return(mean(c(a1head,a1tail)))}
else if (d[row,3]>=a2head&d[row,3]<=a2tail)
{return(mean(c(a2head,a2tail)))}
else if (d[row,3]>=a3head&d[row,3]<=a3tail)
{return(mean(c(a3head,a3tail)))}
else if (d[row,3]>=a4head&d[row,3]<=a4tail)
{return(mean(c(a4head,a4tail)))}
else if (d[row,3]>=a5head&d[row,3]<=a5tail)
{return(mean(c(a5head,a5tail)))}
else if (d[row,3]>=a6head&d[row,3]<=a6tail)
{return(mean(c(a6head,a6tail)))}
else if (d[row,3]>=a7head&d[row,3]<=max(d$gambleDelay))
{return(mean(c(a7head,a7tail)))}
else
{return(999)}
}
for(i in 1:nrow(d)){
d[i,10]=binTimeCalc(d,i)
}
#Creating new df to see how many ended up in each bin
dbins<-d %>%
group_by(binsTime) %>%
summarise(Number=length(response))
dbins
mean(c(a7head,a7tail))
d<-read.csv(file="C:/Users/lab/Documents/GitHub/rampAnalysis/rampV02DataClean.csv",sep=",")
#d0<-read.csv(file.choose(),header=TRUE)
d<-d0
d[d==""] <- NA
d$gambleDelay<-d$gambleDelay/1000
d$binsTime=0;
#Clearing pictures
graphics.off()
#Getting rid of any trial which gamble interrupted too early
#d<-filter(d,gambleDelay<5.6)
histogram(d$gambleDelay,breaks=50,xlim=c(0,7),main="Where gambles interrupted trials. All trials",xlab="seconds into trial gamble appeared")
d=d[d$uniqueid>207,]
unique(d$uniqueid)
colnames(d)[1]<-"Trialid"
bins=8
ninbins=round((length(d$Trialid)/bins))
##Splitting into number of bins you want
#quantile(d$gambleDelay[!0])
#This creates a list with what should be in the binTimeCalc
delayValues=split(sort(d$gambleDelay[d$gambleDelay!=0]), ceiling(seq_along(d$gambleDelay[d$gambleDelay!=0])/ninbins))
View(delayValues)
#This is to manually hardcode the NUMBER of blocks you're using - has to match number of 'blocks' in delayValues
a1head<-unlist(lapply(delayValues[1],head,1),use.names=FALSE)
a1tail<-unlist(lapply(delayValues[1],tail,1),use.names=FALSE)
a2head<-unlist(lapply(delayValues[2],head,1),use.names=FALSE)
a2tail<-unlist(lapply(delayValues[2],tail,1),use.names=FALSE)
a3head<-unlist(lapply(delayValues[3],head,1),use.names=FALSE)
a3tail<-unlist(lapply(delayValues[3],tail,1),use.names=FALSE)
a4head<-unlist(lapply(delayValues[4],head,1),use.names=FALSE)
a4tail<-unlist(lapply(delayValues[4],tail,1),use.names=FALSE)
a5head<-unlist(lapply(delayValues[5],head,1),use.names=FALSE)
a5tail<-unlist(lapply(delayValues[5],tail,1),use.names=FALSE)
a6head<-unlist(lapply(delayValues[6],head,1),use.names=FALSE)
a6tail<-unlist(lapply(delayValues[6],tail,1),use.names=FALSE)
a7head<-unlist(lapply(delayValues[7],head,1),use.names=FALSE)
a7tail<-unlist(lapply(delayValues[7],tail,1),use.names=FALSE)
a8head<-unlist(lapply(delayValues[8],head,1),use.names=FALSE)
a8tail<-unlist(lapply(delayValues[8],tail,1),use.names=FALSE)
a9head<-unlist(lapply(delayValues[9],head,1),use.names=FALSE)
a9tail<-unlist(lapply(delayValues[9],tail,1),use.names=FALSE)
#The number of statements in this function should match
#This block works well for participants 228 on..
binTimeCalc<-function(d,row){
if(d[row,3]==0)
{return(0)}
else if (d[row,3]>0&d[row,3]<=a1tail)
{return(mean(c(a1head,a1tail)))}
else if (d[row,3]>=a2head&d[row,3]<=a2tail)
{return(mean(c(a2head,a2tail)))}
else if (d[row,3]>=a3head&d[row,3]<=a3tail)
{return(mean(c(a3head,a3tail)))}
else if (d[row,3]>=a4head&d[row,3]<=a4tail)
{return(mean(c(a4head,a4tail)))}
else if (d[row,3]>=a5head&d[row,3]<=a5tail)
{return(mean(c(a5head,a5tail)))}
else if (d[row,3]>=a6head&d[row,3]<=a6tail)
{return(mean(c(a6head,a6tail)))}
else if (d[row,3]>=a7head&d[row,3]<=max(d$gambleDelay))
{return(mean(c(a7head,a7tail)))}
else
{return(999)}
}
#Temp code because one of the bins is to big... during V02 analysis
binTimeCalc<-function(d,row){
if(d[row,3]==0)
{return(0)}
else if (d[row,3]>0&d[row,3]<=a1tail)
{return(mean(c(a1head,a1tail)))}
else if (d[row,3]>=a2head&d[row,3]<=a2tail)
{return(mean(c(a2head,a2tail)))}
else if (d[row,3]>=a3head&d[row,3]<=a3tail)
{return(mean(c(a3head,a3tail)))}
else if (d[row,3]>=a4head&d[row,3]<=a4tail)
{return(mean(c(a4head,a4tail)))}
else if (d[row,3]>=a5head&d[row,3]<=5.5999999)
{return(mean(c(a5head,a5tail)))}
else if (d[row,3]==5.6)
{return(5.6)}
else if (d[row,3]>5.6&d[row,3]<5.977)
{return(mean(c(a7head,a8tail)))}
else if (d[row,3]>=a9head&d[row,3]<=a9tail)
{return(mean(c(a9head,a9tail)))}
else
{return(999)}
}
#The number of statements in this function should match
#This block works well for participants 228 on..
binTimeCalc<-function(d,row){
if(d[row,3]==0)
{return(0)}
else if (d[row,3]>0&d[row,3]<=a1tail)
{return(mean(c(a1head,a1tail)))}
else if (d[row,3]>=a2head&d[row,3]<=a2tail)
{return(mean(c(a2head,a2tail)))}
else if (d[row,3]>=a3head&d[row,3]<=a3tail)
{return(mean(c(a3head,a3tail)))}
else if (d[row,3]>=a4head&d[row,3]<=a4tail)
{return(mean(c(a4head,a4tail)))}
else if (d[row,3]>=a5head&d[row,3]<=a5tail)
{return(mean(c(a5head,a5tail)))}
else if (d[row,3]>=a6head&d[row,3]<=a6tail)
{return(mean(c(a6head,a6tail)))}
else if (d[row,3]>=a7head&d[row,3]<=max(d$gambleDelay))
{return(mean(c(a7head,a7tail)))}
else
{return(999)}
}
for(i in 1:nrow(d)){
d[i,10]=binTimeCalc(d,i)
}
#Creating new df to see how many ended up in each bin
dbins<-d %>%
group_by(binsTime) %>%
summarise(Number=length(response))
dbins
unique(d$uniqueid)
#Getting rid of any trial which gamble interrupted too early
#d<-filter(d,gambleDelay<5.6)
histogram(d$gambleDelay,breaks=50,xlim=c(0,7),main="Where gambles interrupted trials. All trials",xlab="seconds into trial gamble appeared")
d<-read.csv(file="C:/Users/lab/Documents/GitHub/rampAnalysis/rampV02DataClean.csv",sep=",")
#d0<-read.csv(file.choose(),header=TRUE)
d<-d0
d[d==""] <- NA
d$gambleDelay<-d$gambleDelay/1000
d$binsTime=0;
#Clearing pictures
graphics.off()
#Getting rid of any trial which gamble interrupted too early
#d<-filter(d,gambleDelay<5.6)
histogram(d$gambleDelay,breaks=50,xlim=c(0,7),main="Where gambles interrupted trials. All trials",xlab="seconds into trial gamble appeared")
d=d[d$uniqueid>227,]
colnames(d)[1]<-"Trialid"
unique(d$uniqueid)
bins=8
ninbins=round((length(d$Trialid)/bins))
##Splitting into number of bins you want
#quantile(d$gambleDelay[!0])
#This creates a list with what should be in the binTimeCalc
delayValues=split(sort(d$gambleDelay[d$gambleDelay!=0]), ceiling(seq_along(d$gambleDelay[d$gambleDelay!=0])/ninbins))
#This is to manually hardcode the NUMBER of blocks you're using - has to match number of 'blocks' in delayValues
a1head<-unlist(lapply(delayValues[1],head,1),use.names=FALSE)
a1tail<-unlist(lapply(delayValues[1],tail,1),use.names=FALSE)
a2head<-unlist(lapply(delayValues[2],head,1),use.names=FALSE)
a2tail<-unlist(lapply(delayValues[2],tail,1),use.names=FALSE)
a3head<-unlist(lapply(delayValues[3],head,1),use.names=FALSE)
a3tail<-unlist(lapply(delayValues[3],tail,1),use.names=FALSE)
a4head<-unlist(lapply(delayValues[4],head,1),use.names=FALSE)
a4tail<-unlist(lapply(delayValues[4],tail,1),use.names=FALSE)
a5head<-unlist(lapply(delayValues[5],head,1),use.names=FALSE)
a5tail<-unlist(lapply(delayValues[5],tail,1),use.names=FALSE)
a6head<-unlist(lapply(delayValues[6],head,1),use.names=FALSE)
a6tail<-unlist(lapply(delayValues[6],tail,1),use.names=FALSE)
a7head<-unlist(lapply(delayValues[7],head,1),use.names=FALSE)
a7tail<-unlist(lapply(delayValues[7],tail,1),use.names=FALSE)
a8head<-unlist(lapply(delayValues[8],head,1),use.names=FALSE)
a8tail<-unlist(lapply(delayValues[8],tail,1),use.names=FALSE)
a9head<-unlist(lapply(delayValues[9],head,1),use.names=FALSE)
a9tail<-unlist(lapply(delayValues[9],tail,1),use.names=FALSE)
#The number of statements in this function should match
#This block works well for participants 228 on..
binTimeCalc<-function(d,row){
if(d[row,3]==0)
{return(0)}
else if (d[row,3]>0&d[row,3]<=a1tail)
{return(mean(c(a1head,a1tail)))}
else if (d[row,3]>=a2head&d[row,3]<=a2tail)
{return(mean(c(a2head,a2tail)))}
else if (d[row,3]>=a3head&d[row,3]<=a3tail)
{return(mean(c(a3head,a3tail)))}
else if (d[row,3]>=a4head&d[row,3]<=a4tail)
{return(mean(c(a4head,a4tail)))}
else if (d[row,3]>=a5head&d[row,3]<=a5tail)
{return(mean(c(a5head,a5tail)))}
else if (d[row,3]>=a6head&d[row,3]<=a6tail)
{return(mean(c(a6head,a6tail)))}
else if (d[row,3]>=a7head&d[row,3]<=max(d$gambleDelay))
{return(mean(c(a7head,a7tail)))}
else
{return(999)}
}
for(i in 1:nrow(d)){
d[i,10]=binTimeCalc(d,i)
}
#Creating new df to see how many ended up in each bin
dbins<-d %>%
group_by(binsTime) %>%
summarise(Number=length(response))
dbins
#Adding which condition trial was in
#For new data set
magCondCalc<-function(d,row){
if(d[row,7]==1|d[row,7]==2){
return("low")
} else if (d[row,7]==3|d[row,7]==4){
return("mid")
} else if (d[row,7]==5|d[row,7]==6){
return("high")
} else{
return("null")
}
}
for(i in 1:nrow(d)){
d[i,11]=magCondCalc(d,i)
}
colnames(d)[11]<-"magCond"
oddsCondCalc<-function(d,row){
if(d[row,1]==21|d[row,1]==22|d[row,1]==23|d[row,1]==24|d[row,1]==25|d[row,1]==26){
return("lowp")
} else if (d[row,1]==1|d[row,1]==2|d[row,1]==3|d[row,1]==4|d[row,1]==5|d[row,1]==6){
return("midp")
} else if (d[row,1]==31|d[row,1]==32|d[row,1]==33|d[row,1]==34|d[row,1]==35|d[row,1]==36){
return("highp")
} else{
return("catch")
}
}
for(i in 1:nrow(d)){
d[i,12]=oddsCondCalc(d,i)
}
colnames(d)[12]<-"oddsCond"
head(d)
participants<-unique(d$uniqueid)
nParticipants<- length(unique(d$uniqueid))
nParticipants
#Check for catch trials
dcatch<-filter(d,Trialid==75|Trialid==86)[,c(1,6,9)]
dcatch[order(dcatch$Trialid),]
catch<-for(i in 1:nrow(dcatch)){
if(dcatch[i,1]==85&dcatch[i,2]=="gamble"){
noCatch<-c(noCatch,dcatch[i,3])
}else if(dcatch[i,1]==75&dcatch[i,2]=="success"){
noCatch<-c(noCatch,dcatch[i,3])
}else if(dcatch[i,1]==75&dcatch[i,2]=="fail"){
noCatch<-c(noCatch,dcatch[i,3])
}
}
nParticipants
###Behavioral analyses
##Reaction time
#Whenever they gambled
gambleRTs<-d$gambleRT[d$gambleRT!=0]
histogram(gambleRTs,main="Aggregated gamble RTs",breaks=70)
#Whenever they claimed 'boring' reward
outcomeRTs<-d$outcomeRT[d$outcomeRT!=0]
histogram(outcomeRTs,main="Aggregated outcome RTs",breaks=70)
#Printing experiment times in minutes CONFIRM PSITURK TRACKS IN MILLISECONDS
expTimes<-((unique(d$expTime,na.rm=TRUE)/1000)/60)
histogram(expTimes,main="Experiment Time (in minutes)",breaks=50)
histogram(expTimes,main="Experiment Time (in minutes)",breaks=50,xlim=c(0,60))
dgamble<-filter(d,gambleDelay!=0)
dBehavioralTotal<-dgamble %>%
group_by(uniqueid) %>%
summarise(experimentTime=unique(expTime,na.rm=TRUE)[2],
trials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/trials*100))
head(dBehavioralTotal)
#Overall preference for gambling
histogram(dBehavioralTotal$percentageGambled,breaks=50,xlim=c(-5,100),ylim=c(0,25),main=paste("Overall participant propensity to gamble; n =",toString(sum(dBehavioralTotal$trials)),"trials;",nParticipants,"participants"),xlab="Percentage of time gambled")
dlowG<-filter(dBehavioralTotal,percentageGambled<6)
noGamblers<-dlowG$uniqueid
dhighg<-filter(dBehavioralTotal,percentageGambled>95)
allGamblers<-dhighg$uniqueid
removeIds<-c(noGamblers,allGamblers)
#Removing any subjects from dataset if needed, using unique ids in vector removeIds
for(i in removeIds){
d<-d[!(d$uniqueid==i),]
}
nParticipants<- length(unique(d$uniqueid))
Participants<-unique(d$uniqueid)
nParticipants
dgamble<-filter(d,gambleDelay!=0)
dBehavioral<-dgamble %>%
group_by(uniqueid) %>%
summarise(experimentTime=unique(expTime)[2],
trials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/trials*100))
histogram(dBehavioral$percentageGambled,breaks=50,xlim=c(-5,100),ylim=c(0,25),main=paste("Overall participant propensity to gamble; n =",toString(sum(dBehavioralTotal$trials)),"trials;",nParticipants,"participants"),xlab="Percentage of time gambled")
#Adding another column 1 if they gambled, 0 if they didn't
#This will be outcome variable in logistic regression
for (i in 1:length(dgamble$response)){
if(dgamble$response[i]=='gamble'){
dgamble$gambled[i]=1
} else {
dgamble$gambled[i]=0
}
}
#Logistic regression for gambled
mlog<-glm(gambled~gambleDelay+magCond+oddsCond+trialNumber,data=dgamble,family="binomial");
summary(mlog)
#Adding RPE as a factor
#Currently only one participant
dsub<-filter(d,uniqueid==228)
dsub[,13]=0
colnames(dsub)[13]<-"PredictionError"
#This is predictionError for trial t-1
pe<-0
a=0
for (row in 1:length(dsub$Trialid)){
dsub[row,13]=(dsub[row,7]-pe)
pe=dsub[i,13]
}
a
#This is predictionError for trial t-1
pe<-0
a=0
for (row in 1:length(dsub$Trialid)){
dsub[row,13]=(dsub[row,7]-pe)
pe=dsub[i,13]
a=c(a,a)
}
#This is predictionError for trial t-1
pe<-0
a=0
for (row in 1:length(dsub$Trialid)){
dsub[row,13]=(dsub[row,7]-pe)
pe=dsub[row,13]
a=c(a,a)
}
#This is predictionError for trial t-1
pe<-0
for (row in 1:length(dsub$Trialid)){
dsub[row,13]=(dsub[row,7]-pe)
pe=dsub[row,13]
}
dsub[1,13]=dsub[1,7]
for (row in 2:length(dsub$Trialid)){
dsub[row,13]=(dsub[row,7]-dsub[(row-1),7])
pe=dsub[row,13]
}
#Adding prediction errors as possible variable
d[,13]=0
a
colnames(d)[13]<-"PredictionError"
View(d)
nParticipants
Participants
#Adding RPE as a factor
#Currently only one participant
for (i in Participants){
dsub<-filter(d,uniqueid==i)
dsub[,13]=0
colnames(dsub)[13]<-"PredictionError"
dsub[1,13]=dsub[1,7]
for (row in 2:length(dsub$Trialid)){
#This is essentially calculating the difference between potential reward on trial
#t - reward on trial t-1
dsub[row,13]=(dsub[row,7]-dsub[(row-1),7])
}
}
d2=d
#Adding RPE as a factor
#Currently only one participant
for (i in Participants){
dsub<-filter(d,uniqueid==i)
dsub[,13]=0
colnames(dsub)[13]<-"PredictionError"
dsub[1,13]=dsub[1,7]
for (row in 2:length(dsub$Trialid)){
#This is essentially calculating the difference between potential reward on trial
#t - reward on trial t-1
dsub[row,13]=(dsub[row,7]-dsub[(row-1),7])
}
d2=rbind(dsub,dsub)
}
d2
View(d2)
#Adding RPE as a factor
#Currently only one participant
for (i in Participants){
dsub<-filter(d,uniqueid==i)
dsub[1,13]=dsub[1,7]
for (row in 2:length(dsub$Trialid)){
#This is essentially calculating the difference between potential reward on trial
#t - reward on trial t-1
dsub[row,13]=(dsub[row,7]-dsub[(row-1),7])
}
d2=rbind(dsub,dsub)
}
unique(d2$uniqueid)
rm(d2)
#Adding RPE as a factor
#Currently only one participant
for (i in Participants){
dsub<-filter(d,uniqueid==i)
dsub[1,13]=dsub[1,7]
for (row in 2:length(dsub$Trialid)){
#This is essentially calculating the difference between potential reward on trial
#t - reward on trial t-1
dsub[row,13]=(dsub[row,7]-dsub[(row-1),7])
}
d2=rbind(d2,dsub)
}
#Adding prediction errors as possible variable
d2=d1[0,]
#Adding prediction errors as possible variable
d2=d[0,]
d[,13]=0
colnames(d)[13]<-"PredictionError"
#Adding RPE as a factor
#Currently only one participant
for (i in Participants){
dsub<-filter(d,uniqueid==i)
dsub[1,13]=dsub[1,7]
for (row in 2:length(dsub$Trialid)){
#This is essentially calculating the difference between potential reward on trial
#t - reward on trial t-1
dsub[row,13]=(dsub[row,7]-dsub[(row-1),7])
}
d2=rbind(d2,dsub)
}
View(d)
View(d2)
d=d2
#Logistic regression for gambled
mlog<-glm(gambled~gambleDelay+magCond+oddsCond+trialNumber+PredictionError,data=dgamble,family="binomial");
summary(mlog)
###Behavioral analyses
##Reaction time
#Whenever they gambled
gambleRTs<-d$gambleRT[d$gambleRT!=0]
histogram(gambleRTs,main="Aggregated gamble RTs",breaks=70)
#Whenever they claimed 'boring' reward
outcomeRTs<-d$outcomeRT[d$outcomeRT!=0]
histogram(outcomeRTs,main="Aggregated outcome RTs",breaks=70)
#Printing experiment times in minutes CONFIRM PSITURK TRACKS IN MILLISECONDS
expTimes<-((unique(d$expTime,na.rm=TRUE)/1000)/60)
histogram(expTimes,main="Experiment Time (in minutes)",breaks=50)
histogram(expTimes,main="Experiment Time (in minutes)",breaks=50,xlim=c(0,60))
#Always run the following block
dgamble<-filter(d,gambleDelay!=0)
dBehavioralTotal<-dgamble %>%
group_by(uniqueid) %>%
summarise(experimentTime=unique(expTime,na.rm=TRUE)[2],
trials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/trials*100))
head(dBehavioralTotal)
#Overall preference for gambling
histogram(dBehavioralTotal$percentageGambled,breaks=50,xlim=c(-5,100),ylim=c(0,25),main=paste("Overall participant propensity to gamble; n =",toString(sum(dBehavioralTotal$trials)),"trials;",nParticipants,"participants"),xlab="Percentage of time gambled")
dlowG<-filter(dBehavioralTotal,percentageGambled<6)
noGamblers<-dlowG$uniqueid
dhighg<-filter(dBehavioralTotal,percentageGambled>95)
allGamblers<-dhighg$uniqueid
removeIds<-c(noGamblers,allGamblers)
nParticipants
dgamble<-filter(d,gambleDelay!=0)
dBehavioral<-dgamble %>%
group_by(uniqueid) %>%
summarise(experimentTime=unique(expTime)[2],
trials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/trials*100))
histogram(dBehavioral$percentageGambled,breaks=50,xlim=c(-5,100),ylim=c(0,25),main=paste("Overall participant propensity to gamble; n =",toString(sum(dBehavioralTotal$trials)),"trials;",nParticipants,"participants"),xlab="Percentage of time gambled")
#Adding another column 1 if they gambled, 0 if they didn't
#This will be outcome variable in logistic regression
for (i in 1:length(dgamble$response)){
if(dgamble$response[i]=='gamble'){
dgamble$gambled[i]=1
} else {
dgamble$gambled[i]=0
}
}
#Logistic regression for gambled
mlog<-glm(gambled~gambleDelay+magCond+oddsCond+trialNumber+PredictionError,data=dgamble,family="binomial");
summary(mlog)
