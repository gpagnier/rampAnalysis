d[i,"uniqueID"]=d[i-1,"uniqueID"]
}
else if (d[i,"uniqueid"]!=d[i-1,"uniqueid"]){
d[i,"uniqueID"]=(d[i-1,"uniqueID"]+1)
}
}
unique(d$uniqueID)
d$uniqueid=d$uniqueID
d$uniqueID=NULL
#############################################################################################################################
#Now we have a dataframe we can work with
#Replace any empty cell with NA
#Colnames should now be:
#"trialid" #"expTime" "gambleDelay" "gambleRT" "outcomeRT" "response" "standardGamble" "trialNumber" "uniqueid"
d[d==""] <- NA
d$gambleDelay<-d$gambleDelay/1000
d$binsTime=0;
#Clearing pictures
graphics.off()
##Some basic behavioral metrics and filtering participants and adding gamble delay
#Intitial filtering of participants
removeIds=c()
for(i in removeIds){
d<-d[!(d$uniqueid==i),]
}
unique(d$uniqueid)
#Where did gambles interrupt
hist(d$gambleDelay,breaks=50,xlim=c(0,8),main="When did gambles interrupt the progress bar?",xlab="Seconds into trial gamble appeared",col='black',ylab="Total number of trials",ylim=c(0,2000))
#How many points do you want on the gambleDelay?
d$binsTme=NULL
bins=6
ninbins=round((length(d$Trialid)/bins))
#This creates a list with what should be in the binTimeCalc
delayValues=split(sort(d$gambleDelay[d$gambleDelay!=0]), ceiling(seq_along(d$gambleDelay[d$gambleDelay!=0])/ninbins))
#This is to manually hardcode the NUMBER of blocks you're using - can not exceed number of bins
a1head<-unlist(lapply(delayValues[1],head,1),use.names=FALSE)
a1tail<-unlist(lapply(delayValues[1],tail,1),use.names=FALSE)
a2head<-unlist(lapply(delayValues[2],head,1),use.names=FALSE)
a2tail<-unlist(lapply(delayValues[2],tail,1),use.names=FALSE)
a3head<-unlist(lapply(delayValues[3],head,1),use.names=FALSE)
a3tail<-unlist(lapply(delayValues[3],tail,1),use.names=FALSE)
a4head<-unlist(lapply(delayValues[4],head,1),use.names=FALSE)
a4tail<-unlist(lapply(delayValues[4],tail,1),use.names=FALSE)
a5head<-unlist(lapply(delayValues[5],head,1),use.names=FALSE)
a5tail<-unlist(lapply(delayValues[5],tail,1),use.names=FALSE)
a6head<-unlist(lapply(delayValues[6],head,1),use.names=FALSE)
a6tail<-unlist(lapply(delayValues[6],tail,1),use.names=FALSE)
a7head<-unlist(lapply(delayValues[7],head,1),use.names=FALSE)
a7tail<-unlist(lapply(delayValues[7],tail,1),use.names=FALSE)
a8head<-unlist(lapply(delayValues[8],head,1),use.names=FALSE)
a8tail<-unlist(lapply(delayValues[8],tail,1),use.names=FALSE)
a9head<-unlist(lapply(delayValues[9],head,1),use.names=FALSE)
a9tail<-unlist(lapply(delayValues[9],tail,1),use.names=FALSE)
a10head<-unlist(lapply(delayValues[10],head,1),use.names=FALSE)
a10tail<-unlist(lapply(delayValues[10],tail,1),use.names=FALSE)
#Manually setting bins
#For totalRampv3
#For 6 bins
a1head<-1.4
a1tail<-1.999999
a2head<-2
a2tail<-2.5
a3head<-3.75
a3tail<-3.999999
a4head<-4
a4tail<-4.5
a5head<-5.8
a5tail<-6.24
a6head<-6.24000000001
a6tail<-6.8
#For 3 bins
# a1head<-1.4
# a1tail<-3.5
# a2head<-3.6
# a2tail<-4.7
# a3head<-5.8
# a3tail<-6.5
#This is the function that creates gambleBins
binTimeCalc<-function(d,row){
if(d[row,'gambleDelay']==0)
{return(0)}
else if (d[row,'gambleDelay']>0&d[row,'gambleDelay']<=a1tail)
{return(mean(c(a1head,a1tail)))}
else if (d[row,'gambleDelay']>=a2head&d[row,'gambleDelay']<=a2tail)
{return(mean(c(a2head,a2tail)))}
else if (d[row,'gambleDelay']>=a3head&d[row,'gambleDelay']<=a3tail)
{return(mean(c(a3head,a3tail)))}
else if (d[row,'gambleDelay']>=a4head&d[row,'gambleDelay']<=a4tail)
{return(mean(c(a4head,a4tail)))}
else if (d[row,'gambleDelay']>=a5head&d[row,'gambleDelay']<=a5tail)
{return(mean(c(a5head,a5tail)))}
else if (d[row,'gambleDelay']>=a6head&d[row,'gambleDelay']<=a6tail)
{return(mean(c(a6head,a6tail)))}
# else if (d[row,'gambleDelay']>=a7head&d[row,'gambleDelay']<=a7tail)
# {return(mean(c(a7head,a7tail)))}
# else if (d[row,'gambleDelay']>=a8head&d[row,'gambleDelay']<=a8tail)
# {return(mean(c(a8head,a8tail)))}
# else if (d[row,'gambleDelay']>=a9head&d[row,'gambleDelay']<=max(d$gambleDelay))
# {return(mean(c(a9head,a9tail)))}
else
{return(999)}
}
#Actually running the functon
for(i in 1:nrow(d)){
d[i,'binsTime']=binTimeCalc(d,i)
}
#Creating new df to see how many ended up in each bin/ this is sanity check
dbins<-d %>%
group_by(binsTime) %>%
summarise(Number=length(response))
dbins
#Remove/coalesce any rows with bins if the numbers are too far apart from one another
# #Right now this takes the last one and adds it to the last 'bin'
# for(i in 1:nrow(d)){
#   if(d[i,"binsTime"]==mean(c(a8head,a8tail))){
#     d[i,"binsTime"]=mean(c(a7head,a7tail))
#     i
#   }
# };
dbins<-d %>%
group_by(binsTime) %>%
summarise(Number=length(response))
dbins
d<-filter(d,binsTime<999)
###################################################################################
#Adding different factors
#Adding which condition trial was in
#For new data set
d$magCond<-NULL
magCondCalc<-function(d,row){
if(d[row,'standardGamble']==1|d[row,'standardGamble']==2){
return("low")
} else if (d[row,'standardGamble']==3|d[row,'standardGamble']==4){
return("mid")
} else if (d[row,'standardGamble']==5|d[row,'standardGamble']==6){
return("high")
} else{
return("null")
}
}
for(i in 1:nrow(d)){
d[i,'magCond']=magCondCalc(d,i)
}
d$oddsCond<-NULL
oddsCondCalc<-function(d,row){
if(d[row,'Trialid']==21|d[row,'Trialid']==22|d[row,'Trialid']==23|d[row,'Trialid']==24|d[row,'Trialid']==25|d[row,'Trialid']==26){
return("lowp")
} else if (d[row,'Trialid']==1|d[row,'Trialid']==2|d[row,'Trialid']==3|d[row,'Trialid']==4|d[row,'Trialid']==5|d[row,'Trialid']==6){
return("midp")
} else if (d[row,'Trialid']==31|d[row,'Trialid']==32|d[row,'Trialid']==33|d[row,'Trialid']==34|d[row,'Trialid']==35|d[row,'Trialid']==36){
return("highp")
} else{
return("catch")
}
}
for(i in 1:nrow(d)){
d[i,'oddsCond']=oddsCondCalc(d,i)
}
#Adding another column 1 if they gambled, 0 if they didn't
#This will be outcome variable in logistic regression
d$gambled=NULL
for (i in 1:length(d$response)){
if(d$response[i]=='gamble'){
d$gambled[i]=1
} else {
d$gambled[i]=0
}
}
#This is a column for highest gamble shown (used to calculate RPE2 and RPE3)
d$gambleMaxAmt=NULL
for (i in 1:length(d$response)){
if(d$oddsCond[i]=='lowp'){
d$gambleMaxAmt[i]=(d$standardGamble[i]*1.5)
} else if(d$oddsCond[i]=='midp'){
d$gambleMaxAmt[i]=(d$standardGamble[i]*2)
}else if(d$oddsCond[i]=='highp'){
d$gambleMaxAmt[i]=(d$standardGamble[i]*3)
} else {
d$gambleMaxAmt[i]=d$standardGamble[i]
}
}
#Adding prediction errors:
#Adding prediction errors as possible variable
d2=d[0,]
#rpe 1 2 and 3
d$rpe1=NULL
d$rpe2=NULL
d$rpe3=NULL
d$gamblePrevTrial=NULL
#RT z score
#Should I do z scores on speed or raw RT?
d$gambleRTz<-NULL
d$outcomeRTz<-NULL
acfdf<-matrix(NA, ncol = 133, nrow =0)
Participants<-unique(d$uniqueid)
for (i in Participants){
dsub<-filter(d,uniqueid==i)
if(length(dsub$gambled)==133){
acfdf<-rbind(acfdf,dsub$gambled)
}
}
#Adding vector to filter out fast RTers
fastRTers<-NULL
#Adding RPE as a factor AND normalized RT z score
#rpe1 is the sure thing of trial t- standard gamble of t-1
#rpe2 is the sure thing of t - the average of whatever was chosen in t-1
#rpe3 is the sure thing of t - whatever was chosen in t-1 but the highest gamble option instead of average
for (i in Participants){
dsub<-filter(d,uniqueid==i)
dsub[1,"rpe1"]=dsub[1,"standardGamble"]
dsub[1,"rpe2"]=dsub[1,"standardGamble"]
dsub[1,"rpe3"]=dsub[1,"standardGamble"]
#This is adding RPE
for (row in 2:length(dsub$Trialid)){
#This is essentially calculating the difference between potential reward on trial
#t - reward on trial t-1
dsub[row,"rpe1"]=(dsub[row,"standardGamble"]-dsub[(row-1),"standardGamble"])
#This is rpe2
#And gamblingPrevTrial
if(dsub[(row-1),"gambled"]){
dsub[row,"rpe2"]=(dsub[row,"standardGamble"]-(dsub[(row-1),"gambleMaxAmt"]/2))
dsub[row,"gamblePrevTrial"]=1
} else{
dsub[row,"rpe2"]=(dsub[row,"standardGamble"]-dsub[(row-1),"standardGamble"])
dsub[row,"gamblePrevTrial"]=0
}
}
#This is rpe3
for (row in 2:length(dsub$Trialid)){
if(dsub[(row-1),"gambled"]){
dsub[row,"rpe3"]=(dsub[row,"standardGamble"]-(dsub[(row-1),"gambleMaxAmt"]))
} else{
dsub[row,"rpe3"]=(dsub[row,"standardGamble"]-dsub[(row-1),"standardGamble"])
}
}
#This is calculating normalized z score for dsub
meanGambleZ=mean(dsub$gambleRT[dsub$gambleRT!=0])
meanOutcomeZ=mean(dsub$outcomeRT[dsub$outcomeRT!=0])
sdGambleZ=sd(dsub$gambleRT[dsub$gambleRT!=0])
sdOutcomeZ=sd(dsub$outcomeRT[dsub$outcomeRT!=0])
for(row in 1:length(dsub$Trialid)){
if(dsub[row,"gambleRT"]!=0){
dsub[row,"gambleRTz"]=(dsub[row,"gambleRT"]-meanGambleZ)/sdGambleZ
} else if(dsub[row,"gambleRT"]==0){
dsub[row,"gambleRTz"]=0
}
if(dsub[row,"outcomeRT"]!=0){
dsub[row,"outcomeRTz"]=(dsub[row,"outcomeRT"]-meanOutcomeZ)/sdOutcomeZ
} else if(dsub[row,"outcomeRT"]==0){
dsub[row,"outcomeRTz"]=0
}
}
#Fitering out fast RTers
if(nrow(filter(dsub,outcomeRT>0&outcomeRT<150))>20){
fastRTers<-c(fastRTers,unique(dsub$uniqueid))
}
d2=rbind(d2,dsub)
}
d=d2
#Normalized RT log(1/RT) to get speed
d$NgambleRT=0
d$NoutcomeRT=0
#Dividing gambleRT by (1/RT) on new column
for(i in 1:length(d$response)){
if(d[i,"gambleRT"]!=0){
d[i,"NgambleRT"]=(1/d[i,"gambleRT"])
}
}
#Dividing OutcomeRT by 1/RT
for(i in 1:length(d$response)){
if(d[i,"outcomeRT"]!=0){
d[i,"NoutcomeRT"]=(1/d[i,"outcomeRT"])
}
}
#########################################################################################################################################
#This should be ready to run now without any artificial filtering of participants for low RT etc.
nParticipants<- length(unique(d$uniqueid))
nParticipants
# #Check for catch trials
# #75 should gamble; 86 should success/fail; 2 catch trials - moved to 6
# #Check for catch trials
# dcatch<-filter(d,Trialid==75|Trialid==86)[,c("Trialid","response","uniqueid")]
# #dcatch[order(dcatch$Trialid),]
# dcatchGamble<-dcatch[dcatch$Trialid==75,]
# failCatchId<-dcatchGamble[dcatchGamble$response=='success'|dcatchGamble$response=='fail',]$uniqueid
#
# dcatchSuccess<-dcatch[dcatch$Trialid==86,]
#
# failCatchId<-unique(c(failCatchId,dcatchSuccess[dcatchSuccess$response=='gamble',]$uniqueid))
# catchSuccessId<-setdiff(Participants,failCatchId)
#
# #Differential analysis of failCatch
# #Called what they SHOULD do
# dcatchidFinish<-dcatch[dcatch$Trialid==86,] %>%
#   group_by(uniqueid) %>%
#   summarise(FailTrials=sum(response=="gamble"|response=='earlyFail'))
#
# dcatchidGamble<-dcatch[dcatch$Trialid==75,] %>%
#   group_by(uniqueid) %>%
#   summarise(FailTrials=sum(response=="fail"|response=='success'|response=='earlyFail'))
#
# dcatchscore<-data.frame(dcatchidFinish$uniqueid)
# colnames(dcatchscore)[1]='uniqueid'
# dcatchscore$failScore<-dcatchidFinish$FailTrials+dcatchidGamble$FailTrials
###Behavioral analyses
##Reaction time
#Whenever they gambled
gambleRTs<-d$gambleRT[d$gambleRT!=0]
hist(gambleRTs,main="Aggregated gamble RTs",breaks=70)
#Whenever they claimed 'boring' reward
outcomeRTs<-d$outcomeRT[d$outcomeRT!=0]
hist(outcomeRTs,main=c("Aggregated outcome RTs; number of trials:",length(outcomeRTs)),breaks=70)
#Printing experiment times in minutes CONFIRM PSITURK TRACKS IN MILLISECONDS
expTimes<-((unique(d$expTime,na.rm=TRUE)/1000)/60)
hist(expTimes,main="Experiment Time (in minutes)",breaks=50,xlim=c(0,120))
#Survey responses
dsurvey<-d %>%
group_by(uniqueid) %>%
summarise(engagement=unique(engagement),
difficulty=unique(difficulty),
length=unique(length),
design=unique(design),
gender=unique(gender),
interest=unique(interest))
dsurvey<-dsurvey[!(is.na(dsurvey$gender)|dsurvey$gender==""),]
#Removing participants who gambled too much/not enough
dgamble0<-filter(d,gambleDelay!=0)
dBehavioralTotal<-dgamble0 %>%
group_by(uniqueid) %>%
summarise(trials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/trials*100))
#head(dBehavioralTotal)
#Overall preference for gambling
hist(dBehavioralTotal$percentageGambled,breaks=50,xlim=c(-5,100),ylim=c(0,25),main=paste("Overall participant propensity(everyone) to gamble; n =",toString(sum(dBehavioralTotal$trials)),"trials;",nParticipants,"participants"),xlab="Percentage of time gambled")
dlowG<-filter(dBehavioralTotal,percentageGambled<6)
noGamblers<-dlowG$uniqueid
dhighg<-filter(dBehavioralTotal,percentageGambled>95)
allGamblers<-dhighg$uniqueid
lowTrials<-filter(dBehavioralTotal,trials<50)$uniqueid
removeIds<-c(noGamblers,allGamblers,lowTrials)
#Removing fastRTers
removeIds<-c(removeIds,fastRTers)
#Removing any subjects from dataset, using unique ids in vector removeIds
for(i in removeIds){
d<-d[!(d$uniqueid==i),]
}
#Check for catch trials
#75 should gamble; 86 should success/fail; 2 catch trials - moved to 6
#Check for catch trials
dcatch<-filter(d,Trialid==75|Trialid==86)[,c("Trialid","response","uniqueid")]
#Differential analysis of failCatch
#Called what they SHOULD do
dcatchidFinish<-dcatch[dcatch$Trialid==86,] %>%
group_by(uniqueid) %>%
summarise(FailTrials=sum(response=="gamble"|response=='earlyFail'))
dcatchidGamble<-dcatch[dcatch$Trialid==75,] %>%
group_by(uniqueid) %>%
summarise(FailTrials=sum(response=="fail"|response=='success'|response=='earlyFail'))
dcatchscore<-data.frame(dcatchidFinish$uniqueid)
colnames(dcatchscore)[1]='uniqueid'
dcatchscore$failScore<-dcatchidFinish$FailTrials+dcatchidGamble$FailTrials
failCatchId<-unique(dcatchscore$uniqueid[dcatchscore$failScore>0])
catchSuccessId<-unique(dcatchscore$uniqueid[dcatchscore$failScore==0])
#Breaking down catchTrials by severity
fail1<-unique(dcatchscore$uniqueid[dcatchscore$failScore==1])
fail2<-unique(dcatchscore$uniqueid[dcatchscore$failScore==2])
fail3<-unique(dcatchscore$uniqueid[dcatchscore$failScore==3])
fail4<-unique(dcatchscore$uniqueid[dcatchscore$failScore==4])
fail5<-unique(dcatchscore$uniqueid[dcatchscore$failScore==5])
fail6<-unique(dcatchscore$uniqueid[dcatchscore$failScore==6])
#Now this is refined number of participants
nParticipants<- length(unique(d$uniqueid))
Participants<-unique(d$uniqueid)
nParticipants
acf1
subj<-unique(d$uniqueid)
intN<-NULL
botN<-NULL
rtn<-NULL
oddsN<-NULL
oddsNtemp<-data.frame(matrix(NA, ncol = 2, nrow =1))
colnames(oddsNtemp)[1]<-"OddsGamblingScore"
colnames(oddsNtemp)[2]<-"Participant"
magN<-NULL
magNtemp<-data.frame(matrix(NA, ncol = 2, nrow =1))
colnames(magNtemp)[1]<-"MagGamblingScore"
colnames(magNtemp)[2]<-"Participant"
acf1<-NULL
acf2<-NULL
acf3<-NULL
acf4<-NULL
acf5<-NULL
rtSlopes<-NULL
gambleSlopes<-NULL
run<-NULL
slopeDF<-NULL
plotRT=FALSE
plotGD=FALSE
#Participants is default (all participants)
#If you want to run sub groups, go to bottom of script
for(i in Participants){
print(i)
dsub<-d[d$uniqueid==i,]
dsubgambled<-filter(dsub,response=="gamble")
dsubhigh<-filter(dsub,Trialid==31|Trialid==32|Trialid==33|Trialid==34|Trialid==35|Trialid==36)
dsublow<-filter(dsub,Trialid==21|Trialid==22|Trialid==23|Trialid==24|Trialid==25|Trialid==26)
#Breaking down by subFilter
d4behavioralHigh<-dsubhigh %>%
group_by(uniqueid) %>%
summarise(trials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/trials*100))
d4behavioralLow<-dsublow %>%
group_by(uniqueid) %>%
summarise(trials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/trials*100))
oddsNtemp[1,1]=as.integer(d4behavioralHigh$gambleCount-d4behavioralLow$gambleCount)
oddsNtemp[1,2]=as.character(i)
oddsN=rbind(oddsN,oddsNtemp)
dsubhigh<-filter(dsub,Trialid==5|Trialid==6|Trialid==25|Trialid==26|Trialid==35|Trialid==36)
dsublow<-filter(dsub,Trialid==1|Trialid==2|Trialid==21|Trialid==22|Trialid==31|Trialid==32)
d4behavioralHigh<-dsubhigh %>%
group_by(uniqueid) %>%
summarise(trials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/trials*100))
d4behavioralLow<-dsublow %>%
group_by(uniqueid) %>%
summarise(trials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/trials*100))
magNtemp[1,1]=as.integer(d4behavioralHigh$gambleCount-d4behavioralLow$gambleCount)
magNtemp[1,2]=as.character(i)
magN=rbind(magNtemp,magN)
#Breaking down subdf by gambleDelay
d4<-dsub[dsub$gambleDelay!=0,] %>%
group_by(binsTime) %>%
summarise(trials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/trials*100))
d4$seconds<-d4$binsTime
if (plotGD){
plot(d4$seconds,d4$percentageGambled,xlim = c(0,7),ylim = c(0,100),
main=paste("Individual participant data; n =",toString(sum(d4$trials)),"trials;","participant:",toString(unique(dsub$uniqueid))),
xlab="Seconds into trial",ylab="Percentage Gambled",pch=19)
}
#One participant RT
d4RT<-filter(dsub,gambleRT!=0) %>%
group_by(binsTime) %>%
summarise(medianRT=median(gambleRT),
sdRT=sd(gambleRT))
d4RT$seconds<-d4RT$binsTime
if (plotRT){
plot(d4RT$seconds,d4RT$meanRT,xlim = c(0,8),ylim=c(400,1000),
main=paste("Individual participant RT; n =",toString(sum(d4$trials)),"trials;","participant:",toString(unique(dsub$uniqueid))),
xlab="Seconds into trial",ylab="Reaction time (seconds)",pch=19)
}
#This is top check for gamble ramp
mlogtemp<-glm(gambled~gambleDelay,data=filter(dsub,gambleDelay!=0),family="binomial")
#This is glm for RT by gamble Delay
mtempRT<-lm(d4RT$medianRT~d4RT$seconds)
#This checks to see if any participant is gamble ramping
if(summary(mlogtemp)$coefficients[8]<.1 & summary(mlogtemp)$coefficients[2]>0){
intN<-c(intN,i)
}
#Check to see if any participant has a RT that's susupiciously low..
if(mean(setdiff(dsub$outcomeRT,0),na.rm=TRUE)<200){
botN<-c(botN,i)
}
#Check to see if participant has a downwards decreasing RT ramp
if(summary(mtempRT)$coefficients[8]<.1 & summary(mtempRT)$coefficients[2]<0){
rtn<-c(rtn,i)
}
#Making acf coefficient vectors
acf1<-c(acf1,acf(dsub$gambled,lag.max=5,plot = FALSE)$acf[2])
acf2<-c(acf2,acf(dsub$gambled,lag.max=5,plot = FALSE)$acf[3])
acf3<-c(acf3,acf(dsub$gambled,lag.max=5,plot = FALSE)$acf[4])
acf4<-c(acf4,acf(dsub$gambled,lag.max=5,plot = FALSE)$acf[5])
acf5<-c(acf5,acf(dsub$gambled,lag.max=5,plot = FALSE)$acf[6])
#Making df of gambleSlopes, rtSlopes, and i (who was just analyzed)
rtSlopes<-c(rtSlopes,summary(mtempRT)$coefficients[2])
gambleSlopes<-c(gambleSlopes,summary(mlogtemp)$coefficients[2])
run<-c(run,i)
}
slopeDF<-data.frame(cbind(run,rtSlopes,gambleSlopes))
a<-oddsN[order(oddsN$OddsGamblingScore),]
#oddsN is the median split of people who respond well to odds
oddsN<-as.integer(a$Participant[(length(a$Participant)/2):length(a$Participant)])
#Quartile split
oddsN<-oddsN[(length(oddsN)/2):(length(oddsN))]
acf1
hist(acf1,breaks=50)
hist(acf1,breaks=50,main="ACF constants for each participant, lag of 1")
hist(acf2,breaks=50,main="ACF constants for each participant, lag of 2")
hist(acf3,breaks=50,main="ACF constants for each participant, lag of 3")
hist(acf4,breaks=50,main="ACF constants for each participant, lag of 4")
hist(acf5,breaks=50,main="ACF constants for each participant, lag of 5")
hist(acf1,breaks=50,main="ACF constants for each participant, lag of 1",xlim=c(-1,1))
hist(acf2,breaks=50,main="ACF constants for each participant, lag of 2")
hist(acf3,breaks=50,main="ACF constants for each participant, lag of 3")
hist(acf2,breaks=50,main="ACF constants for each participant, lag of 2",xlim=c(-1,1))
hist(acf3,breaks=50,main="ACF constants for each participant, lag of 3",xlim=c(-1,1))
hist(acf4,breaks=50,main="ACF constants for each participant, lag of 4",xlim=c(-1,1))
hist(acf5,breaks=50,main="ACF constants for each participant, lag of 5",xlim=c(-1,1))
