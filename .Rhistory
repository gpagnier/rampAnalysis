d$binsTime=0;
#Clearing pictures
graphics.off()
##Some basic behavioral metrics and filtering participants and adding gamble delay
#Intitial filtering of participants
removeIds=c()
for(i in removeIds){
d<-d[!(d$uniqueid==i),]
}
unique(d$uniqueid)
#Where did gambles interrupt
histogram(d$gambleDelay,breaks=50,xlim=c(0,8),main="Where gambles interrupted trials. All trials",xlab="seconds into trial gamble appeared")
colnames(d)[1]<-"Trialid"
bins=9
ninbins=round((length(d$Trialid)/bins))
#This creates a list with what should be in the binTimeCalc
delayValues=split(sort(d$gambleDelay[d$gambleDelay!=0]), ceiling(seq_along(d$gambleDelay[d$gambleDelay!=0])/ninbins))
#This is to manually hardcode the NUMBER of blocks you're using - can not exceed number of bins
a1head<-unlist(lapply(delayValues[1],head,1),use.names=FALSE)
a1tail<-unlist(lapply(delayValues[1],tail,1),use.names=FALSE)
a2head<-unlist(lapply(delayValues[2],head,1),use.names=FALSE)
a2tail<-unlist(lapply(delayValues[2],tail,1),use.names=FALSE)
a3head<-unlist(lapply(delayValues[3],head,1),use.names=FALSE)
a3tail<-unlist(lapply(delayValues[3],tail,1),use.names=FALSE)
a4head<-unlist(lapply(delayValues[4],head,1),use.names=FALSE)
a4tail<-unlist(lapply(delayValues[4],tail,1),use.names=FALSE)
a5head<-unlist(lapply(delayValues[5],head,1),use.names=FALSE)
a5tail<-unlist(lapply(delayValues[5],tail,1),use.names=FALSE)
a6head<-unlist(lapply(delayValues[6],head,1),use.names=FALSE)
a6tail<-unlist(lapply(delayValues[6],tail,1),use.names=FALSE)
a7head<-unlist(lapply(delayValues[7],head,1),use.names=FALSE)
a7tail<-unlist(lapply(delayValues[7],tail,1),use.names=FALSE)
a8head<-unlist(lapply(delayValues[8],head,1),use.names=FALSE)
a8tail<-unlist(lapply(delayValues[8],tail,1),use.names=FALSE)
a9head<-unlist(lapply(delayValues[9],head,1),use.names=FALSE)
a9tail<-unlist(lapply(delayValues[9],tail,1),use.names=FALSE)
a10head<-unlist(lapply(delayValues[10],head,1),use.names=FALSE)
a10tail<-unlist(lapply(delayValues[10],tail,1),use.names=FALSE)
#The number of statements in this function should match
#This block works well for participants 228 on..
binTimeCalc<-function(d,row){
if(d[row,3]==0)
{return(0)}
else if (d[row,3]>0&d[row,3]<=a1tail)
{return(mean(c(a1head,a1tail)))}
else if (d[row,3]>=a2head&d[row,3]<=a2tail)
{return(mean(c(a2head,a2tail)))}
else if (d[row,3]>=a3head&d[row,3]<=a3tail)
{return(mean(c(a3head,a3tail)))}
else if (d[row,3]>=a4head&d[row,3]<=a4tail)
{return(mean(c(a4head,a4tail)))}
else if (d[row,3]>=a5head&d[row,3]<=a5tail)
{return(mean(c(a5head,a5tail)))}
else if (d[row,3]>=a6head&d[row,3]<=a6tail)
{return(mean(c(a6head,a6tail)))}
else if (d[row,3]>=a7head&d[row,3]<=a7tail)
{return(mean(c(a7head,a7tail)))}
else if (d[row,3]>=a8head&d[row,3]<=a8tail)
{return(mean(c(a8head,a8tail)))}
else if (d[row,3]>=a9head&d[row,3]<=max(d$gambleDelay))
{return(mean(c(a9head,a9tail)))}
else
{return(999)}
}
for(i in 1:nrow(d)){
d[i,10]=binTimeCalc(d,i)
}
#Creating new df to see how many ended up in each bin/ this is sanity check
dbins<-d %>%
group_by(binsTime) %>%
summarise(Number=length(response))
dbins
#Remove/coalesce any rows with bins if the numbers are too far apart from one another
#Highly conditional, should hardcode for every dataset
#Right now this takes the last one and adds it to the last 'bin'
for(i in 1:nrow(d)){
if(d[i,"binsTime"]==mean(c(a8head,a8tail))){
d[i,"binsTime"]=mean(c(a7head,a7tail))
i
}
};
dbins<-d %>%
group_by(binsTime) %>%
summarise(Number=length(response))
dbins
#Adding which condition trial was in
#For new data set
magCondCalc<-function(d,row){
if(d[row,7]==1|d[row,7]==2){
return("low")
} else if (d[row,7]==3|d[row,7]==4){
return("mid")
} else if (d[row,7]==5|d[row,7]==6){
return("high")
} else{
return("null")
}
}
for(i in 1:nrow(d)){
d[i,11]=magCondCalc(d,i)
}
colnames(d)[11]<-"magCond"
oddsCondCalc<-function(d,row){
if(d[row,1]==21|d[row,1]==22|d[row,1]==23|d[row,1]==24|d[row,1]==25|d[row,1]==26){
return("lowp")
} else if (d[row,1]==1|d[row,1]==2|d[row,1]==3|d[row,1]==4|d[row,1]==5|d[row,1]==6){
return("midp")
} else if (d[row,1]==31|d[row,1]==32|d[row,1]==33|d[row,1]==34|d[row,1]==35|d[row,1]==36){
return("highp")
} else{
return("catch")
}
}
for(i in 1:nrow(d)){
d[i,12]=oddsCondCalc(d,i)
}
colnames(d)[12]<-"oddsCond"
##Loading packages
#install.packages('mosaic')
library(mosaic)
##Loading data
#d0<-read.csv(file="C:/Users/lab/Documents/GitHub/rampAnalysis/5ramp9.10.csv",sep=",")
d0<-read.csv(file="C:/Users/Guillaume/Documents/GitHub/rampAnalysis/Totalrampv02.csv",sep=",")
#Cleaning data
bonusAmountsTemp=data.frame(matrix(NA, ncol = 2, nrow =1))
bonusAmounts=bonusAmountsTemp
for (i in 1:length(d0$BonusAmount)){
if(!is.na(d0[i,2])){
bonusAmountsTemp[1,1]=as.integer(d0[i,"BonusAmount"])
bonusAmountsTemp[1,2]=as.character(d0[i,"uniqueid"])
bonusAmounts=rbind(bonusAmounts,bonusAmountsTemp)
}
}
bonusAmounts=bonusAmounts[-1,]
colnames(bonusAmounts)[1]<-"Amount"
colnames(bonusAmounts)[2]<-"ID"
bonusAmounts<-unique(bonusAmounts)
bonusAmounts
#Need to replace uniqueid with numbers and clean out columns that aren't useful
d<-d0[,c("Trialid","expTime","gambleDelay","gambleRT","outcomeRT","response","standardGamble","trialNumber","uniqueid")]
d<-subset(d,!grepl("debug",as.character(d$uniqueid)))
d<-subset(d,d$response!="")
#Adding col uniqueID uniqueid with numbers
d$uniqueID=NA
seed=201
d[1,"uniqueID"]<-seed
for (i in 2:nrow(d)){
if(d[i,"uniqueid"]==d[i-1,"uniqueid"]){
d[i,"uniqueID"]=d[i-1,"uniqueID"]
}
else if (d[i,"uniqueid"]!=d[i-1,"uniqueid"]){
d[i,"uniqueID"]=(d[i-1,"uniqueID"]+1)
}
}
unique(d$uniqueID)
d$uniqueid=d$uniqueID
d$uniqueID=NULL
d[d==""] <- NA
d$gambleDelay<-d$gambleDelay/1000
d$binsTime=0;
#Clearing pictures
graphics.off()
##Some basic behavioral metrics and filtering participants and adding gamble delay
#Intitial filtering of participants
removeIds=c()
for(i in removeIds){
d<-d[!(d$uniqueid==i),]
}
unique(d$uniqueid)
#Where did gambles interrupt
histogram(d$gambleDelay,breaks=50,xlim=c(0,8),main="Where gambles interrupted trials. All trials",xlab="seconds into trial gamble appeared")
colnames(d)[1]<-"Trialid"
bins=9
ninbins=round((length(d$Trialid)/bins))
#This creates a list with what should be in the binTimeCalc
delayValues=split(sort(d$gambleDelay[d$gambleDelay!=0]), ceiling(seq_along(d$gambleDelay[d$gambleDelay!=0])/ninbins))
#This is to manually hardcode the NUMBER of blocks you're using - can not exceed number of bins
a1head<-unlist(lapply(delayValues[1],head,1),use.names=FALSE)
a1tail<-unlist(lapply(delayValues[1],tail,1),use.names=FALSE)
a2head<-unlist(lapply(delayValues[2],head,1),use.names=FALSE)
a2tail<-unlist(lapply(delayValues[2],tail,1),use.names=FALSE)
a3head<-unlist(lapply(delayValues[3],head,1),use.names=FALSE)
a3tail<-unlist(lapply(delayValues[3],tail,1),use.names=FALSE)
a4head<-unlist(lapply(delayValues[4],head,1),use.names=FALSE)
a4tail<-unlist(lapply(delayValues[4],tail,1),use.names=FALSE)
a5head<-unlist(lapply(delayValues[5],head,1),use.names=FALSE)
a5tail<-unlist(lapply(delayValues[5],tail,1),use.names=FALSE)
a6head<-unlist(lapply(delayValues[6],head,1),use.names=FALSE)
a6tail<-unlist(lapply(delayValues[6],tail,1),use.names=FALSE)
a7head<-unlist(lapply(delayValues[7],head,1),use.names=FALSE)
a7tail<-unlist(lapply(delayValues[7],tail,1),use.names=FALSE)
a8head<-unlist(lapply(delayValues[8],head,1),use.names=FALSE)
a8tail<-unlist(lapply(delayValues[8],tail,1),use.names=FALSE)
a9head<-unlist(lapply(delayValues[9],head,1),use.names=FALSE)
a9tail<-unlist(lapply(delayValues[9],tail,1),use.names=FALSE)
a10head<-unlist(lapply(delayValues[10],head,1),use.names=FALSE)
a10tail<-unlist(lapply(delayValues[10],tail,1),use.names=FALSE)
#The number of statements in this function should match
#This block works well for participants 228 on..
binTimeCalc<-function(d,row){
if(d[row,3]==0)
{return(0)}
else if (d[row,3]>0&d[row,3]<=a1tail)
{return(mean(c(a1head,a1tail)))}
else if (d[row,3]>=a2head&d[row,3]<=a2tail)
{return(mean(c(a2head,a2tail)))}
else if (d[row,3]>=a3head&d[row,3]<=a3tail)
{return(mean(c(a3head,a3tail)))}
else if (d[row,3]>=a4head&d[row,3]<=a4tail)
{return(mean(c(a4head,a4tail)))}
else if (d[row,3]>=a5head&d[row,3]<=a5tail)
{return(mean(c(a5head,a5tail)))}
else if (d[row,3]>=a6head&d[row,3]<=a6tail)
{return(mean(c(a6head,a6tail)))}
else if (d[row,3]>=a7head&d[row,3]<=a7tail)
{return(mean(c(a7head,a7tail)))}
else if (d[row,3]>=a8head&d[row,3]<=a8tail)
{return(mean(c(a8head,a8tail)))}
else if (d[row,3]>=a9head&d[row,3]<=max(d$gambleDelay))
{return(mean(c(a9head,a9tail)))}
else
{return(999)}
}
for(i in 1:nrow(d)){
d[i,10]=binTimeCalc(d,i)
}
#Creating new df to see how many ended up in each bin/ this is sanity check
dbins<-d %>%
group_by(binsTime) %>%
summarise(Number=length(response))
dbins
#Remove/coalesce any rows with bins if the numbers are too far apart from one another
#Highly conditional, should hardcode for every dataset
#Right now this takes the last one and adds it to the last 'bin'
for(i in 1:nrow(d)){
if(d[i,"binsTime"]==mean(c(a8head,a8tail))){
d[i,"binsTime"]=mean(c(a7head,a7tail))
i
}
};
dbins<-d %>%
group_by(binsTime) %>%
summarise(Number=length(response))
dbins
#Adding which condition trial was in
#For new data set
magCondCalc<-function(d,row){
if(d[row,7]==1|d[row,7]==2){
return("low")
} else if (d[row,7]==3|d[row,7]==4){
return("mid")
} else if (d[row,7]==5|d[row,7]==6){
return("high")
} else{
return("null")
}
}
for(i in 1:nrow(d)){
d[i,11]=magCondCalc(d,i)
}
colnames(d)[11]<-"magCond"
oddsCondCalc<-function(d,row){
if(d[row,1]==21|d[row,1]==22|d[row,1]==23|d[row,1]==24|d[row,1]==25|d[row,1]==26){
return("lowp")
} else if (d[row,1]==1|d[row,1]==2|d[row,1]==3|d[row,1]==4|d[row,1]==5|d[row,1]==6){
return("midp")
} else if (d[row,1]==31|d[row,1]==32|d[row,1]==33|d[row,1]==34|d[row,1]==35|d[row,1]==36){
return("highp")
} else{
return("catch")
}
}
for(i in 1:nrow(d)){
d[i,12]=oddsCondCalc(d,i)
}
colnames(d)[12]<-"oddsCond"
#Adding prediction errors:
#Adding prediction errors as possible variable
d2=d[0,]
d[,13]=0
colnames(d)[13]<-"PredictionError"
Participants<-unique(d$uniqueid)
#Adding RPE as a factor
#Currently only one participant
for (i in Participants){
dsub<-filter(d,uniqueid==i)
dsub[1,13]=dsub[1,7]
for (row in 2:length(dsub$Trialid)){
#This is essentially calculating the difference between potential reward on trial
#t - reward on trial t-1
dsub[row,13]=(dsub[row,7]-dsub[(row-1),7])
}
d2=rbind(d2,dsub)
}
head(d2)
d=d2
nParticipants<- length(unique(d$uniqueid))
nParticipants
#Check for catch trials
#This prints off the trial ids of anyone who made a mistake
#75 should gamble; 86 should success/fail; 2 catch trials?
head(d)
###Behavioral analyses
##Reaction time
#Whenever they gambled
gambleRTs<-d$gambleRT[d$gambleRT!=0]
histogram(gambleRTs,main="Aggregated gamble RTs",breaks=70)
#Whenever they claimed 'boring' reward
outcomeRTs<-d$outcomeRT[d$outcomeRT!=0]
histogram(outcomeRTs,main=c("Aggregated outcome RTs; number of trials:",length(outcomeRTs)),breaks=70)
#Printing experiment times in minutes CONFIRM PSITURK TRACKS IN MILLISECONDS
expTimes<-((unique(d$expTime,na.rm=TRUE)/1000)/60)
histogram(expTimes,main="Experiment Time (in minutes)",breaks=50,xlim=c(0,60))
dgamble0<-filter(d,gambleDelay!=0)
dBehavioralTotal<-dgamble0 %>%
group_by(uniqueid) %>%
summarise(trials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/trials*100))
head(dBehavioralTotal)
#Overall preference for gambling
histogram(dBehavioralTotal$percentageGambled,breaks=50,xlim=c(-5,100),ylim=c(0,25),main=paste("Overall participant propensity(everyone) to gamble; n =",toString(sum(dBehavioralTotal$trials)),"trials;",nParticipants,"participants"),xlab="Percentage of time gambled")
dlowG<-filter(dBehavioralTotal,percentageGambled<6)
noGamblers<-dlowG$uniqueid
dhighg<-filter(dBehavioralTotal,percentageGambled>95)
allGamblers<-dhighg$uniqueid
removeIds<-c(noGamblers,allGamblers)
#Removing any subjects from dataset if needed, using unique ids in vector removeIds
for(i in removeIds){
d<-d[!(d$uniqueid==i),]
}
#Now this is refinde number of participants
nParticipants<- length(unique(d$uniqueid))
Participants<-unique(d$uniqueid)
nParticipants
#######################################################################################################
#Clearing pictures
graphics.off()
#Behavioral analyses
dgamble<-filter(d,gambleDelay!=0)
dBehavioral<-dgamble %>%
group_by(uniqueid) %>%
summarise(experimentTime=unique(expTime)[2],
trials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/trials*100))
histogram(dBehavioral$percentageGambled,breaks=50,xlim=c(-5,100),ylim=c(0,25),main=paste("Overall participant propensity to gamble; n =",toString(sum(dBehavioralTotal$trials)),"trials;",nParticipants,"participants"),xlab="Percentage of time gambled")
#Remaking behavioral histograms
#Whenever they gambled
gambleRTs<-d$gambleRT[d$gambleRT!=0]
histogram(gambleRTs,main="Aggregated gamble RTs",breaks=70)
c("Numberof trials that they gambled on: ",length(gambleRTs))
#Whenever they claimed 'boring' reward
outcomeRTs<-d$outcomeRT[d$outcomeRT!=0]
histogram(outcomeRTs,main="Aggregated outcome RTs; number of trials:",breaks=70)
c("Numberof trials that they gambled on: ",length(outcomeRTs))
#Adding another column 1 if they gambled, 0 if they didn't
#This will be outcome variable in logistic regression
for (i in 1:length(dgamble$response)){
if(dgamble$response[i]=='gamble'){
dgamble$gambled[i]=1
} else {
dgamble$gambled[i]=0
}
}
#Number of trials per participant
dTrials<-d %>%
group_by(uniqueid) %>%
summarise(ntrials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/ntrials*100))
dTrials
histogram(dTrials$ntrials,breaks=50,xlim=c(0,120),ylim=c(0,30),main=paste("Number of trials per participant; ",nParticipants,"participants"),xlab="Number of Trials per participant")
dBehavioralTotal
lowTrials<-filter(dBehavioralTotal,percentageGambled>95)$uniqueid
lowTrials
removeIds<-c(noGamblers,allGamblers,lowTrials)
#Removing any subjects from dataset if needed, using unique ids in vector removeIds
for(i in removeIds){
d<-d[!(d$uniqueid==i),]
}
#Now this is refinde number of participants
nParticipants<- length(unique(d$uniqueid))
Participants<-unique(d$uniqueid)
nParticipants
#Number of trials per participant
dTrials<-d %>%
group_by(uniqueid) %>%
summarise(ntrials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/ntrials*100))
dTrials
histogram(dTrials$ntrials,breaks=50,xlim=c(0,120),ylim=c(0,30),main=paste("Number of trials per participant; ",nParticipants,"participants"),xlab="Number of Trials per participant")
lowTrials<-filter(dBehavioralTotal,percentageGambled>95)$uniqueid
removeIds<-c(noGamblers,allGamblers,lowTrials)
#Removing any subjects from dataset if needed, using unique ids in vector removeIds
for(i in removeIds){
d<-d[!(d$uniqueid==i),]
}
#Now this is refinde number of participants
nParticipants<- length(unique(d$uniqueid))
Participants<-unique(d$uniqueid)
nParticipants
filter(dBehavioralTotal,percentageGambled>95)$uniqueid
removeIds
lowTrials<-filter(dBehavioralTotal,ntrials<60)$uniqueid
dBehavioralTotal
lowTrials<-filter(dBehavioralTotal,trials<60)$uniqueid
lowTrials
lowTrials<-filter(dBehavioralTotal,trials<50)$uniqueid
removeIds<-c(noGamblers,allGamblers,lowTrials)
#Removing any subjects from dataset if needed, using unique ids in vector removeIds
for(i in removeIds){
d<-d[!(d$uniqueid==i),]
}
#Now this is refinde number of participants
nParticipants<- length(unique(d$uniqueid))
Participants<-unique(d$uniqueid)
nParticipants
#######################################################################################################
#Clearing pictures
graphics.off()
#Behavioral analyses
dgamble<-filter(d,gambleDelay!=0)
dBehavioral<-dgamble %>%
group_by(uniqueid) %>%
summarise(experimentTime=unique(expTime)[2],
trials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/trials*100))
histogram(dBehavioral$percentageGambled,breaks=50,xlim=c(-5,100),ylim=c(0,25),main=paste("Overall participant propensity to gamble; n =",toString(sum(dBehavioralTotal$trials)),"trials;",nParticipants,"participants"),xlab="Percentage of time gambled")
#Remaking behavioral histograms
#Whenever they gambled
gambleRTs<-d$gambleRT[d$gambleRT!=0]
histogram(gambleRTs,main="Aggregated gamble RTs",breaks=70)
c("Numberof trials that they gambled on: ",length(gambleRTs))
#Whenever they claimed 'boring' reward
outcomeRTs<-d$outcomeRT[d$outcomeRT!=0]
histogram(outcomeRTs,main="Aggregated outcome RTs; number of trials:",breaks=70)
c("Numberof trials that they gambled on: ",length(outcomeRTs))
#Adding another column 1 if they gambled, 0 if they didn't
#This will be outcome variable in logistic regression
for (i in 1:length(dgamble$response)){
if(dgamble$response[i]=='gamble'){
dgamble$gambled[i]=1
} else {
dgamble$gambled[i]=0
}
}
#Number of trials per participant
dTrials<-d %>%
group_by(uniqueid) %>%
summarise(ntrials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/ntrials*100))
dTrials
histogram(dTrials$ntrials,breaks=50,xlim=c(0,120),ylim=c(0,30),main=paste("Number of trials per participant; ",nParticipants,"participants"),xlab="Number of Trials per participant")
#Logistic regression for gambled
#Need to figure out which one to use
mlog<-glm(gambled~trialNumber+PredictionError+gambleDelay*oddsCond+
gambleDelay*magCond+
PredictionError*gambleDelay,
data=dgamble,family="binomial");
summary(mlog)
mlog2<-glm(gambled~trialNumber+PredictionError+
gambleDelay+oddsCond+magCond+PredictionError,
data=dgamble,family="binomial");
summary(mlog2)
##Total data
c("Number of trials that they gambled on: ",length(d$gambleRT[d$gambleRT!=0]))
c("Number of trials that they had the chance to gamble on: ",length(d$gambleDelay))
#By GambleDelay
d2<-d %>%
group_by(binsTime) %>%
summarise(trials=length(trialNumber),
gambleCount=sum(response=="gamble"),
didNotGamble=sum(response=="fail"|response=="success"),
percentageGambled=round(gambleCount/trials*100),
medianRT=median(setdiff(gambleRT,0)),
sdRT=sd(gambleRT))
d2$seconds<-d2$binsTime
d2=filter(d2,binsTime!=0)
d2
#Interesting plot of gambleDelay vs propensity to gamble. Add sds? May be meaningless..
plot(d2$seconds,d2$percentageGambled,xlim = c(0,8),ylim = c(0,100),
main=paste("Total group data; Gamble propensity; n =",toString(sum(d2$trials)),"trials;"),
xlab="Seconds into trial",ylab="Percentage Gambled",pch=19)
#Plotting RTs with sd
dRT<-filter(d,gambleRT!=0) %>%
group_by(binsTime) %>%
summarise(medianRT=mean(gambleRT),
sdRT=sd(gambleRT))
dRT$seconds<-dRT$binsTime
plot(dRT$seconds,dRT$medianRT,xlim = c(0,8),ylim=c(400,1000),main=paste("Group data; total data; median RT with sd; n =",toString(sum(d2$trials)),"trials;"),
xlab="Seconds into trial",ylab="Reaction time (seconds)",pch=19)
for(i in 1:length(dRT$seconds)){
arrows(as.numeric(dRT$seconds[i]),as.numeric(dRT[i,2]+(as.numeric(dRT[i,3]))),as.numeric(dRT$seconds[i]),as.numeric(dRT[i,2]-(as.numeric(dRT[i,3]))),length=0.05, angle=90, code=3)
}
head(d)
head(di)
head(dsub)
log(5)
#Normalized RT log(1/RT)
d[,14]=0
colnames(d)[14]<-"NormalizedRT"
Participants<-unique(d$uniqueid)
